diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4a6abba..b01d070 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -19,26 +19,36 @@
 # OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED
 # OF THE POSSIBILITY OF SUCH DAMAGES
 cmake_minimum_required(VERSION 3.0)
-project(nvpipe)
+
+set(NVPIPE "nvpipe")
+
+project(${NVPIPE})
+
+# Configuration
+set(config_install_dir "lib/cmake/${PROJECT_NAME}")
+set(include_install_dir "include")
+set(generated_dir "${CMAKE_CURRENT_BINARY_DIR}/generated")
+set(project_config "${generated_dir}/${PROJECT_NAME}Config.cmake")
+
+configure_file(
+    "cmake/Config.cmake.in"
+    "${project_config}")
 
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -g")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -g")
 
-set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99 -pthread")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -pthread")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99 -pthread -fPIC")
+#set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=gnu++11 -pthread")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -pthread -fPIC")
 
 include_directories(${CMAKE_SOURCE_DIR})
 #set(CMAKE_LIBRARY_PATH ${CMAKE_LIBRARY_PATH} $ENV{LD_LIBRARY_PATH})
 link_directories($ENV{LD_LIBRARY_PATH})
 
-message($ENV{LD_LIBRARY_PATH})
-# AJ library
-set(NVPIPE "nvpipe")
-
 find_package(CUDA)
 
-#add_library(${NVPIPE}
-cuda_add_library(${NVPIPE}
+cuda_add_library(${NVPIPE} SHARED
+    #cuda_add_library(${NVPIPE}
     ${CMAKE_SOURCE_DIR}/libnvpipecodec/nvpipecodec.cxx
     ${CMAKE_SOURCE_DIR}/libnvpipecodec/nvpipecodec264.cxx
     ${CMAKE_SOURCE_DIR}/libnvpipeutil/util.cxx
@@ -90,14 +100,13 @@ endif(PKG_CONFIG_FOUND)
 # some extra lib needed
 target_link_libraries (${NVPIPE} "-lm -lX11 -lva -lva-drm -lva-x11 -lvdpau")
 
-add_executable(test_app ${CMAKE_SOURCE_DIR}/doc/example/test.c)
-
-target_link_libraries(test_app ${NVPIPE})
-
-#add_executable(benchmark 
-cuda_add_executable(benchmark 
-                ${CMAKE_SOURCE_DIR}/doc/example/benchmark.cxx
-                ${CMAKE_SOURCE_DIR}/doc/example/file_io.cxx)
+# build example application
+add_subdirectory("./doc/example")
 
-target_link_libraries(benchmark ${NVPIPE})
-target_link_libraries(benchmark "-lnvToolsExt")
+install(FILES nvpipe.h DESTINATION include)
+install(FILES libnvpipecodec/nvpipecodec264.h libnvpipecodec/nvpipecodec.h 
+        DESTINATION include/libnvpipecodec/)
+install(FILES libnvpipeutil/format.h libnvpipeutil/formatConversionCuda.h
+        DESTINATION include/libnvpipeutil/)
+install(TARGETS ${NVPIPE} DESTINATION lib)
+install(FILES "${project_config}" DESTINATION lib/cmake/${NVPIPE})
diff --git a/CMakeLists.txt_bak b/CMakeLists.txt_bak
new file mode 100644
index 0000000..4a6abba
--- /dev/null
+++ b/CMakeLists.txt_bak
@@ -0,0 +1,103 @@
+# Copyright (c) 2016 NVIDIA Corporation.  All rights reserved.
+#
+# NVIDIA Corporation and its licensors retain all intellectual
+# property and proprietary rights in and to this software,
+# related documentation and any modifications thereto.  Any use,
+# reproduction, disclosure or distribution of this software and
+# related documentation without an express license agreement from
+# NVIDIA Corporation is strictly prohibited.
+#
+# TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE
+# IS PROVIDED *AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL
+# WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED
+# TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+# PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS BE
+# LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL
+# DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
+# LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS
+# INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF
+# OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGES
+cmake_minimum_required(VERSION 3.0)
+project(nvpipe)
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -g")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -g")
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99 -pthread")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -pthread")
+
+include_directories(${CMAKE_SOURCE_DIR})
+#set(CMAKE_LIBRARY_PATH ${CMAKE_LIBRARY_PATH} $ENV{LD_LIBRARY_PATH})
+link_directories($ENV{LD_LIBRARY_PATH})
+
+message($ENV{LD_LIBRARY_PATH})
+# AJ library
+set(NVPIPE "nvpipe")
+
+find_package(CUDA)
+
+#add_library(${NVPIPE}
+cuda_add_library(${NVPIPE}
+    ${CMAKE_SOURCE_DIR}/libnvpipecodec/nvpipecodec.cxx
+    ${CMAKE_SOURCE_DIR}/libnvpipecodec/nvpipecodec264.cxx
+    ${CMAKE_SOURCE_DIR}/libnvpipeutil/util.cxx
+    ${CMAKE_SOURCE_DIR}/libnvpipeutil/kernels.cu
+)
+
+# using pkg-config to get ffmpeg
+find_package(PkgConfig)
+if (PKG_CONFIG_FOUND)
+
+  pkg_check_modules(AVDEVICE "libavdevice")
+  if (AVDEVICE_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVDEVICE_LIBRARIES})
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${AVDEVICE_CFLAGS}")
+  endif(AVDEVICE_FOUND)
+
+  pkg_check_modules(AVFILTER "libavfilter")
+  if (AVFILTER_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVFILTER_LIBRARIES})
+  endif(AVFILTER_FOUND)
+
+  pkg_check_modules(AVFORMAT "libavformat")
+  if (AVFORMAT_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVFORMAT_LIBRARIES})
+  endif(AVFORMAT_FOUND)
+
+  pkg_check_modules(AVCODEC "libavcodec")
+  if (AVCODEC_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVCODEC_LIBRARIES})
+  endif(AVCODEC_FOUND)
+
+  pkg_check_modules(AVSWRESAMPLE "libswresample")
+  if (AVSWRESAMPLE_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVSWRESAMPLE_LIBRARIES})
+  endif(AVSWRESAMPLE_FOUND)
+
+  pkg_check_modules(AVSWSCALE "libswscale")
+  if (AVSWSCALE_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVSWSCALE_LIBRARIES})
+  endif(AVSWSCALE_FOUND)
+
+  pkg_check_modules(AVUTIL "libavutil")
+  if (AVUTIL_FOUND)    
+    target_link_libraries(${NVPIPE} ${AVUTIL_LIBRARIES})
+  endif(AVUTIL_FOUND)
+
+endif(PKG_CONFIG_FOUND)
+
+# some extra lib needed
+target_link_libraries (${NVPIPE} "-lm -lX11 -lva -lva-drm -lva-x11 -lvdpau")
+
+add_executable(test_app ${CMAKE_SOURCE_DIR}/doc/example/test.c)
+
+target_link_libraries(test_app ${NVPIPE})
+
+#add_executable(benchmark 
+cuda_add_executable(benchmark 
+                ${CMAKE_SOURCE_DIR}/doc/example/benchmark.cxx
+                ${CMAKE_SOURCE_DIR}/doc/example/file_io.cxx)
+
+target_link_libraries(benchmark ${NVPIPE})
+target_link_libraries(benchmark "-lnvToolsExt")
diff --git a/cmake/Config.cmake.in b/cmake/Config.cmake.in
new file mode 100644
index 0000000..58687a0
--- /dev/null
+++ b/cmake/Config.cmake.in
@@ -0,0 +1,3 @@
+add_library(nvpipe STATIC IMPORTED)
+find_library(NVPIPE_LIBRARY_PATH nvpipe HINTS "${CMAKE_INSTALL_PREFIX}/lib/"}
+set_target_properties(nvpipe PROPERTIES IMPORTED_LOCATION "@NVPIPE_LIBRARY_PATH@")
diff --git a/doc/example/CMakeLists.txt b/doc/example/CMakeLists.txt
new file mode 100644
index 0000000..a5d4b79
--- /dev/null
+++ b/doc/example/CMakeLists.txt
@@ -0,0 +1,49 @@
+# Copyright (c) 2016 NVIDIA Corporation.  All rights reserved.
+#
+# NVIDIA Corporation and its licensors retain all intellectual
+# property and proprietary rights in and to this software,
+# related documentation and any modifications thereto.  Any use,
+# reproduction, disclosure or distribution of this software and
+# related documentation without an express license agreement from
+# NVIDIA Corporation is strictly prohibited.
+#
+# TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE
+# IS PROVIDED *AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL
+# WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED
+# TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+# PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS BE
+# LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL
+# DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
+# LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS
+# INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF
+# OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGES
+cmake_minimum_required(VERSION 3.0)
+#project(nvpipe)
+
+#set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -g")
+#set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -g")
+
+#set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99 -pthread")
+#set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -pthread")
+
+#include_directories(${CMAKE_SOURCE_DIR})
+#link_directories($ENV{LD_LIBRARY_PATH})
+
+# AJ library
+set(NVPIPE "nvpipe")
+#link_directories($ENV{LD_LIBRARY_PATH})
+#find_package(CUDA)
+
+# some extra lib needed
+add_executable(test_app ${CMAKE_SOURCE_DIR}/doc/example/test.c)
+
+target_link_libraries(test_app ${NVPIPE})
+
+#add_executable(benchmark 
+cuda_add_executable(benchmark 
+                ${CMAKE_SOURCE_DIR}/doc/example/benchmark.cxx
+                ${CMAKE_SOURCE_DIR}/doc/example/file_io.cxx)
+
+target_link_libraries(benchmark ${NVPIPE})
+target_link_libraries(benchmark "-lnvToolsExt")
diff --git a/doc/example/test.c b/doc/example/test.c
index a65e78c..5120d78 100644
--- a/doc/example/test.c
+++ b/doc/example/test.c
@@ -1,382 +1,458 @@
-#include <stdio.h>
-#include <inttypes.h>
-#include "nvpipe.h"
-
-void SaveBufferNV12(uint8_t *data, int width, int height, char *str) {
-  FILE *pFile;
-  
-  pFile=fopen(str, "wb");
-  if(pFile==NULL)
-	return;
-
-  // Write header
-  fprintf(pFile, "P5\n%d %d\n255\n", width, height);
-
-  // Write pixel data
-  for(int y=0; y<height; y++)
-	fwrite(data+y*width, 1, width, pFile);
-  
-  // Close file
-  fclose(pFile);
-}
-
-void SaveBufferARGB(uint8_t *data, int width, int height, char *str) {
-  FILE *pFile;
-  
-  // Open file
-  pFile=fopen(str, "wb");
-  if(pFile==NULL)
-    return;
-  
-  // Write header
-  fprintf(pFile, "P6\n%d %d\n255\n", width, height);
-
-  uint8_t *row = malloc( sizeof(uint8_t) * width * 3 );
-
-  // Write pixel data
-  for(int y=0; y<height; y++) {
-    for (int x=0; x<width; x++) {
-      int index = x + y*width;
-      row[x*3] = data[index*4+1];
-      row[x*3+1] = data[index*4+2];
-      row[x*3+2] = data[index*4+3];
+    #include <stdio.h>
+    #include <inttypes.h>
+    #include "nvpipe.h"
+
+    void SaveBufferNV12(uint8_t *data, int width, int height, char *str) {
+      FILE *pFile;
+      
+      pFile=fopen(str, "wb");
+      if(pFile==NULL)
+        return;
+
+      // Write header
+      fprintf(pFile, "P5\n%d %d\n255\n", width, height);
+
+      // Write pixel data
+      for(int y=0; y<height; y++)
+        fwrite(data+y*width, 1, width, pFile);
+      
+      // Close file
+      fclose(pFile);
     }
-    fwrite(row, 1, width*3, pFile);
-  }
-  
-  free (row);
-  // Close file
-  fclose(pFile);
-}
-
-
-void SaveBufferRGB(uint8_t *data, int width, int height, char *str) {
-  FILE *pFile;
-  
-  // Open file
-  pFile=fopen(str, "wb");
-  if(pFile==NULL)
-    return;
-  
-  // Write header
-  fprintf(pFile, "P6\n%d %d\n255\n", width, height);
-
-  uint8_t *row = malloc( sizeof(uint8_t) * width * 3 );
-
-  // Write pixel data
-  for(int y=0; y<height; y++) {
-    fwrite(data, 1, width*3, pFile);
-    data += width*3;
-  }
-  // Close file
-  fclose(pFile);
-}
-
-
-static void*
-pa_alloc(size_t sz) {
-	void* rv;
-	const int err = posix_memalign(&rv, 4096, sz);
-	if(0 != err) {
-		fprintf(stderr, "%zu-byte allocation failed.\n", sz);
-		return NULL;
-	}
-	return rv;
-}
-
-
-void SaveBufferYUV420P(uint8_t *data, int width, int height, char *str) {
-  FILE *pFile;
-  char szFilename[32];
-  int  y;
-
-  // Open file
-  sprintf(szFilename, str);
-  pFile=fopen(szFilename, "wb");
-  if(pFile==NULL)
-	return;
-
-  // Write header
-  fprintf(pFile, "P5\n%d %d\n255\n", width, height);
-
-  // Write pixel data
-  for(y=0; y<height; y++)
-	fwrite(data+y*width, 1, width, pFile);
-  
-  // Close file
-  fclose(pFile);
-}
-
-
-void SaveBufferBit(uint8_t *data, int length, char *str) {
-  FILE *pFile;
-  char szFilename[32];
-  int  y;
-
-  // Open file
-  sprintf(szFilename, str);
-  pFile=fopen(szFilename, "wb");
-  if(pFile==NULL)
-	return;
-
-  fwrite(data, 1, length, pFile);
-  
-  // Close file
-  fclose(pFile);
-}
-
-
-static void pgm_save(unsigned char *buf, int wrap, int xsize, int ysize,
-                     char *filename)
-{
-    FILE *f;
-    int i;
-    f = fopen(filename,"w");
-    fprintf(f, "P5\n%d %d\n%d\n", xsize, ysize, 255);
-    for (i = 0; i < ysize; i++)
-        fwrite(buf + i * wrap, 1, xsize, f);
-    fclose(f);
-}
-
-
-int main( int argc, char* argv[] ) {
-
-    /*
-    int width = 640;
-    int height = 480;
-    uint8_t* rgb_img_ptr = malloc(sizeof(uint8_t)*width*height*4);
-    uint8_t* nv12_img_ptr = malloc(sizeof(uint8_t)*width*height*3/2);
-
-    for ( int i = 0; i < 10; i++ ) {
-        for ( int y = 0; y < height; y++ ) {
-            for ( int x = 0; x < width; x++ ) {
-                int index = x + y * width;
-                rgb_img_ptr[index*4] = 0;
-                rgb_img_ptr[index*4+1] = x*2+y+i*12;//255;
-                rgb_img_ptr[index*4+2] = x+y+12;
-                rgb_img_ptr[index*4+3] = x+y*2+i*2;
-            }
+
+    void SaveBufferARGB(uint8_t *data, int width, int height, char *str) {
+      FILE *pFile;
+      
+      // Open file
+      pFile=fopen(str, "wb");
+      if(pFile==NULL)
+        return;
+      
+      // Write header
+      fprintf(pFile, "P6\n%d %d\n255\n", width, height);
+
+      uint8_t *row = malloc( sizeof(uint8_t) * width * 3 );
+
+      // Write pixel data
+      for(int y=0; y<height; y++) {
+        for (int x=0; x<width; x++) {
+          int index = x + y*width;
+          row[x*3] = data[index*4+1];
+          row[x*3+1] = data[index*4+2];
+          row[x*3+2] = data[index*4+3];
         }
-        SaveBufferARGB(rgb_img_ptr, width, height, "original_rgb.pgm");
-        formatConversion(width, height, rgb_img_ptr, 
-                        nv12_img_ptr, NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12);
-        
-        SaveBufferNV12(nv12_img_ptr, width, height, "nv12.pgm");
-        
-        //formatConversion(width, height, nv12_img_ptr, 
-        //                rgb_img_ptr, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB);
-        formatConversion(width, height, nv12_img_ptr, 
-                        rgb_img_ptr, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB);
-        
-        SaveBufferRGB(rgb_img_ptr, width, height, "decoded_rgb.pgm");
+        fwrite(row, 1, width*3, pFile);
+      }
+      
+      free (row);
+      // Close file
+      fclose(pFile);
     }
-    free (rgb_img_ptr);
-    free (nv12_img_ptr);
-    return 0;
-    */
-
-    /*
-    nvpipe* codec = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
-
-    int width=640;
-    int height=480;
-    size_t buffer_size = sizeof(uint8_t)*width*height*3/2;
-    printf("%zu is the size;", buffer_size);
-    void* img_buffer = pa_alloc(buffer_size);
-    size_t img_buffer_size = buffer_size;
-    uint8_t* img_ptr0 = img_buffer;
-    uint8_t* img_ptr1 = img_ptr0 + (width*height);
-    uint8_t* img_ptr2 = img_ptr1 + (width*height) / 4;
-    
-    int gap0 = width;
-    int gap1 = width/2;
-    int gap2 = width/4;
-    
-
-    void* pkt_buffer = pa_alloc(buffer_size);
-    size_t pkt_buffer_size = buffer_size;
-
-    for ( int i = 0; i < 20; i++ ) {
-        
-        
-        pkt_buffer_size = buffer_size;
-        img_buffer_size = buffer_size;
-
-        if ( i < 10 ) {
-            width = 640;
-            height = 480;
-        } else {
-            width = 320;
-            height = 240;
-        }
 
-        for(size_t y=0;y<height;y++) {
-            for(size_t x=0;x<width;x++) {
-                    img_ptr0[y * width + x] = (x + y + i*10);
-            }
+    void SaveBufferRGBA(uint8_t *data, int width, int height, char *str) {
+      FILE *pFile;
+      
+      // Open file
+      pFile=fopen(str, "wb");
+      if(pFile==NULL)
+        return;
+      
+      // Write header
+      fprintf(pFile, "P6\n%d %d\n255\n", width, height);
+
+      uint8_t *row = malloc( sizeof(uint8_t) * width * 3 );
+
+      // Write pixel data
+      for(int y=0; y<height; y++) {
+        for (int x=0; x<width; x++) {
+          int index = x + y*width;
+          row[x*3] = data[index*4];
+          row[x*3+1] = data[index*4+1];
+          row[x*3+2] = data[index*4+2];
         }
- 
-        for(size_t y=0;y<height/2;y++) {
-            for(size_t x=0;x<width/2;x++) {
-                img_ptr1[y * gap1 + x] = 128 + y;
-                img_ptr2[y * gap2 + x] = 64 + x;
-            }
-    }*/
-    
-    nvpipe* codec = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
-    //nvpipe* codec2 = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
-    int width = 1280;
-    int height = 720;
-    size_t buffer_size = sizeof(uint8_t)*width*height*3;
-    void* img_buffer = malloc(buffer_size);
-    //void* img_buffer = pa_alloc(buffer_size);
-    size_t img_buffer_size = buffer_size;
-    uint8_t* img_ptr0 = img_buffer;
-
-    void** pkt_buffer_list[5];
-    size_t pkt_buffer_size_list[5];
-
-    //void* pkt_buffer = pa_alloc(buffer_size);
-    for ( int i = 0; i < 5; i++ ) {
-        void* pkt_buffer = malloc(buffer_size);
-        pkt_buffer_list[i] = pkt_buffer;
-        pkt_buffer_size_list[i] = buffer_size;
+        fwrite(row, 1, width*3, pFile);
+      }
+      
+      free (row);
+      // Close file
+      fclose(pFile);
     }
-    
-    size_t pkt_buffer_size = buffer_size;
 
-    for ( int i = 0; i < 5; i++ ) {
 
-        pkt_buffer_size = buffer_size;
-        img_buffer_size = buffer_size;
+    void SaveBufferRGB(uint8_t *data, int width, int height, char *str) {
+      FILE *pFile;
+      
+      // Open file
+      pFile=fopen(str, "wb");
+      if(pFile==NULL)
+        return;
+      
+      // Write header
+      fprintf(pFile, "P6\n%d %d\n255\n", width, height);
+
+      uint8_t *row = malloc( sizeof(uint8_t) * width * 3 );
+
+      // Write pixel data
+      for(int y=0; y<height; y++) {
+        fwrite(data, 1, width*3, pFile);
+        data += width*3;
+      }
+      // Close file
+      fclose(pFile);
+    }
 
 
-        width = 1280;
-        height = 720;
-        if ( i == 60 ) {
-            nvpipe_set_bitrate(codec, 10000);
+    static void*
+    pa_alloc(size_t sz) {
+        void* rv;
+        const int err = posix_memalign(&rv, 4096, sz);
+        if(0 != err) {
+            fprintf(stderr, "%zu-byte allocation failed.\n", sz);
+            return NULL;
         }
+        return rv;
+    }
 
-        for(size_t y=0;y<height;y++) {
-            for(size_t x=0;x<width;x++) {
-                int index = y * width + x;
-                img_ptr0[index*3] = 0;
-                img_ptr0[index*3+1] = 0;
-                img_ptr0[index*3+2] = 0;
-            }
-        }
 
-        char str[15];
-        
-        int num = i % 100;
+    void SaveBufferYUV420P(uint8_t *data, int width, int height, char *str) {
+      FILE *pFile;
+      char szFilename[32];
+      int  y;
 
-        sprintf(str, "encoded_file%d.pgm", num);
-        SaveBufferRGB(img_buffer, width, height, str);
-        nvpipe_encode(codec, img_buffer, buffer_size, pkt_buffer_list[i], &(pkt_buffer_size_list[i]), width, height, NVPIPE_IMAGE_FORMAT_RGB);
-        printf( "frame: %d, packet size: %zu\n", i, pkt_buffer_size_list[i]);
-        
+      // Open file
+      sprintf(szFilename, str);
+      pFile=fopen(szFilename, "wb");
+      if(pFile==NULL)
+        return;
+
+      // Write header
+      fprintf(pFile, "P5\n%d %d\n255\n", width, height);
+
+      // Write pixel data
+      for(y=0; y<height; y++)
+        fwrite(data+y*width, 1, width, pFile);
+      
+      // Close file
+      fclose(pFile);
     }
 
-    for ( int i = 0; i < 5; i++) {
-        char str[15];
-        if (nvpipe_decode(codec, pkt_buffer_list[i], pkt_buffer_size_list[i], img_buffer, &img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_RGB) == 0 ) {
-            //if (nvpipe_decode(codec, pkt_buffer, pkt_buffer_size, img_buffer, &img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_NV12) == 0 ) {
-                sprintf(str, "decoded_file%d.pgm", i);
-                SaveBufferRGB(img_buffer, width, height, str);
-                //SaveBufferNV12(img_buffer, width, height, str);
-                
-                //formatConversion(width, height, img_buffer, pkt_buffer, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB);
-                //sprintf(str, "decoded_file_conv%d.pgm", i);
-                //SaveBufferRGB(pkt_buffer, width, height, str);
 
-        }
+    void SaveBufferBit(uint8_t *data, int length, char *str) {
+      FILE *pFile;
+      char szFilename[32];
+      int  y;
+
+      // Open file
+      sprintf(szFilename, str);
+      pFile=fopen(szFilename, "wb");
+      if(pFile==NULL)
+        return;
+
+      fwrite(data, 1, length, pFile);
+      
+      // Close file
+      fclose(pFile);
+    }
+
+
+    size_t ReadFromFile(char* file_name, void* data, size_t size) {
+        FILE *pFile;
+        size_t read_size;
+        // Open file
+        pFile=fopen(file_name, "rb");
+
+        if(pFile==NULL)
+            return 0;
+
+        // read data
+        read_size = fread(data, 1, size, pFile);
+
+        // Close file
+        fclose(pFile);
+
+        return read_size;
     }
 
-    nvpipe_destroy_instance(codec);
-    //nvpipe_destroy_instance(codec2);
 
-    free(img_buffer);
-    for ( int i = 0; i < 5; i++ ) {
-        free(pkt_buffer_list[i]);
+    static void pgm_save(unsigned char *buf, int wrap, int xsize, int ysize,
+                         char *filename)
+    {
+        FILE *f;
+        int i;
+        f = fopen(filename,"w");
+        fprintf(f, "P5\n%d %d\n%d\n", xsize, ysize, 255);
+        for (i = 0; i < ysize; i++)
+            fwrite(buf + i * wrap, 1, xsize, f);
+        fclose(f);
     }
 
-    return 0;
-    /*
-    
-    nvpipe* codec = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
-    //nvpipe* codec2 = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
-    int width = 4096;
-    int height = 2048;
-    size_t buffer_size = sizeof(uint8_t)*width*height*3;
-    void* img_buffer = malloc(buffer_size);
-    //void* img_buffer = pa_alloc(buffer_size);
-    size_t img_buffer_size = buffer_size;
-    uint8_t* img_ptr0 = img_buffer;
-
-    void** pkt_buffer_list[5];
-
-    //void* pkt_buffer = pa_alloc(buffer_size);
-    void* pkt_buffer = malloc(buffer_size);
-    
-    size_t pkt_buffer_size = buffer_size;
-
-    for ( int i = 0; i < 5; i++ ) {
-
-        pkt_buffer_size = buffer_size;
-        img_buffer_size = buffer_size;
-
-        //if ( i > 20 ) {
-        if ( 1 ) {
-            width = 4096;
-            height = 2048;
-        } else {
-            width = 1280;
-            height = 720;
+
+    int main( int argc, char* argv[] ) {
+
+        /*
+        int width = 640;
+        int height = 480;
+        uint8_t* rgb_img_ptr = malloc(sizeof(uint8_t)*width*height*4);
+        uint8_t* nv12_img_ptr = malloc(sizeof(uint8_t)*width*height*3/2);
+
+        for ( int i = 0; i < 10; i++ ) {
+            for ( int y = 0; y < height; y++ ) {
+                for ( int x = 0; x < width; x++ ) {
+                    int index = x + y * width;
+                    rgb_img_ptr[index*4] = 0;
+                    rgb_img_ptr[index*4+1] = x*2+y+i*12;//255;
+                    rgb_img_ptr[index*4+2] = x+y+12;
+                    rgb_img_ptr[index*4+3] = x+y*2+i*2;
+                }
+            }
+            SaveBufferARGB(rgb_img_ptr, width, height, "original_rgb.pgm");
+            formatConversion(width, height, rgb_img_ptr, 
+                            nv12_img_ptr, NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12);
+            
+            SaveBufferNV12(nv12_img_ptr, width, height, "nv12.pgm");
+            
+            //formatConversion(width, height, nv12_img_ptr, 
+            //                rgb_img_ptr, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB);
+            formatConversion(width, height, nv12_img_ptr, 
+                            rgb_img_ptr, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB);
+            
+            SaveBufferRGB(rgb_img_ptr, width, height, "decoded_rgb.pgm");
         }
+        free (rgb_img_ptr);
+        free (nv12_img_ptr);
+        return 0;
+        */
+
+        /*
+        nvpipe* codec = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
+
+        int width=640;
+        int height=480;
+        size_t buffer_size = sizeof(uint8_t)*width*height*3/2;
+        printf("%zu is the size;", buffer_size);
+        void* img_buffer = pa_alloc(buffer_size);
+        size_t img_buffer_size = buffer_size;
+        uint8_t* img_ptr0 = img_buffer;
+        uint8_t* img_ptr1 = img_ptr0 + (width*height);
+        uint8_t* img_ptr2 = img_ptr1 + (width*height) / 4;
         
-        if ( i == 60 ) {
-            nvpipe_set_bitrate(codec, 10000);
+        int gap0 = width;
+        int gap1 = width/2;
+        int gap2 = width/4;
+        
+
+        void* pkt_buffer = pa_alloc(buffer_size);
+        size_t pkt_buffer_size = buffer_size;
+
+        for ( int i = 0; i < 20; i++ ) {
+            
+            
+            pkt_buffer_size = buffer_size;
+            img_buffer_size = buffer_size;
+
+            if ( i < 10 ) {
+                width = 640;
+                height = 480;
+            } else {
+                width = 320;
+                height = 240;
+            }
+
+            for(size_t y=0;y<height;y++) {
+                for(size_t x=0;x<width;x++) {
+                        img_ptr0[y * width + x] = (x + y + i*10);
+                }
+            }
+     
+            for(size_t y=0;y<height/2;y++) {
+                for(size_t x=0;x<width/2;x++) {
+                    img_ptr1[y * gap1 + x] = 128 + y;
+                    img_ptr2[y * gap2 + x] = 64 + x;
+                }
+        }*/
+        /*
+        nvpipe* codec = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
+        //nvpipe* codec2 = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
+        //int width = 4096;
+        //int height = 2048;
+        int width = 4096;
+        int height = 2048;
+        size_t buffer_size = sizeof(uint8_t)*width*height*3;
+        void* img_buffer = malloc(buffer_size);
+        //void* img_buffer = pa_alloc(buffer_size);
+        size_t img_buffer_size = buffer_size;
+        uint8_t* img_ptr0 = img_buffer;
+
+        void** pkt_buffer_list[5];
+        size_t pkt_buffer_size_list[5];
+
+        //void* pkt_buffer = pa_alloc(buffer_size);
+        for ( int i = 0; i < 5; i++ ) {
+            void* pkt_buffer = malloc(buffer_size);
+            pkt_buffer_list[i] = pkt_buffer;
+            pkt_buffer_size_list[i] = buffer_size;
         }
+        
+        size_t pkt_buffer_size = buffer_size;
+
+        for ( int i = 0; i < 5; i++ ) {
+
+            pkt_buffer_size = buffer_size;
+            img_buffer_size = buffer_size;
+
+            //if ( i > 20 ) {
+            if ( 1 ) {
+                width = 4096;
+                height = 2048;
+            } else {
+                width = 1280;
+                height = 720;
+            }
+            
+            if ( i == 60 ) {
+                nvpipe_set_bitrate(codec, 10000);
+            }
 
+            for(size_t y=0;y<height;y++) {
+                for(size_t x=0;x<width;x++) {
+                    int index = y * width + x;
+                    img_ptr0[index*3] = (x + y + i*10);
+                    img_ptr0[index*3+1] = 128 + y + i *15;
+                    img_ptr0[index*3+2] = 64 + x;
+                }
+            }
+      
+            char str[15];
+            
+            int num = i % 100;
+
+            sprintf(str, "encoded_file%d.pgm", num);
+            SaveBufferRGB(img_buffer, width, height, str);
+            nvpipe_encode(codec, img_buffer, buffer_size, pkt_buffer_list[i], &(pkt_buffer_size_list[i]), width, height, NVPIPE_IMAGE_FORMAT_RGB);
+            printf( "frame: %d, packet size: %zu\n", i, pkt_buffer_size_list[i]);
+            
+        }
+
+        for ( int i = 0; i < 5; i++) {
+            char str[15];
+            if (nvpipe_decode(codec, pkt_buffer_list[i], pkt_buffer_size_list[i], img_buffer, &img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_RGB) == 0 ) {
+                //if (nvpipe_decode(codec, pkt_buffer, pkt_buffer_size, img_buffer, &img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_NV12) == 0 ) {
+                    sprintf(str, "decoded_file%d.pgm", i);
+                    SaveBufferRGB(img_buffer, width, height, str);
+                    //SaveBufferNV12(img_buffer, width, height, str);
+                    
+                    //formatConversion(width, height, img_buffer, pkt_buffer, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB);
+                    //sprintf(str, "decoded_file_conv%d.pgm", i);
+                    //SaveBufferRGB(pkt_buffer, width, height, str);
+
+            }
+        }
+
+        nvpipe_destroy_instance(codec);
+        //nvpipe_destroy_instance(codec2);
+
+        free(img_buffer);
+        for ( int i = 0; i < 5; i++ ) {
+            free(pkt_buffer_list[i]);
+        }
+
+        return 0;
+        */
+        
+        nvpipe* codec = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
+        nvpipe* codec2 = nvpipe_create_instance(NVPIPE_CODEC_ID_H264);
+        int width = 1560;
+        int height = 860;
+
+        size_t buffer_size = sizeof(uint8_t)*width*height*4;
+        void* img_buffer = malloc(buffer_size);
+        //void* img_buffer = pa_alloc(buffer_size);
+        size_t img_buffer_size = buffer_size;
+        uint8_t* img_ptr0 = img_buffer;
+        //void* pkt_buffer = pa_alloc(buffer_size);
+        void* pkt_buffer = malloc(buffer_size);
+        size_t pkt_buffer_size = buffer_size;
+        
+        
         for(size_t y=0;y<height;y++) {
             for(size_t x=0;x<width;x++) {
                 int index = y * width + x;
-                img_ptr0[index*3] = (x + y + i*10);
-                img_ptr0[index*3+1] = 128 + y + i *15;
-                img_ptr0[index*3+2] = 64 + x;
+                img_ptr0[index*3] = x+y;
+                img_ptr0[index*3+1] = x;
+                img_ptr0[index*3+2] = 0;
+                //img_ptr0[index*4+3] = 255;
             }
         }
+        SaveBufferRGB(img_buffer, width, height, "encode_receive_buffer.pgm");
+        nvpipe_encode(codec, img_buffer, buffer_size, pkt_buffer, &pkt_buffer_size, width, height, NVPIPE_IMAGE_FORMAT_RGBA);
+        printf("encoding size: %zu\n", pkt_buffer_size);
+        //size_t ssss = 441;
+        //ReadFromFile("receive_buffer_file", pkt_buffer, ssss);
+        nvpipe_decode(codec, pkt_buffer, pkt_buffer_size, img_buffer, img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_RGBA);
+        SaveBufferRGB(img_buffer, width, height, "decode_receive_buffer.pgm");
+        nvpipe_destroy_instance(codec);
+        nvpipe_destroy_instance(codec2);
+        free(img_buffer);
+        free(pkt_buffer);
+        return 0;
+
 
-        char str[15];
         
-        int num = i % 100;
-
-        sprintf(str, "encoded_file%d.pgm", num);
-        SaveBufferRGB(img_buffer, width, height, str);
-        nvpipe_encode(codec, img_buffer, buffer_size, pkt_buffer, &pkt_buffer_size, width, height, NVPIPE_IMAGE_FORMAT_RGB);
-        printf( "frame: %d, packet size: %zu\n", i, pkt_buffer_size);
-        if (nvpipe_decode(codec, pkt_buffer, pkt_buffer_size, img_buffer, &img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_RGB) == 0 ) {
-        //if (nvpipe_decode(codec, pkt_buffer, pkt_buffer_size, img_buffer, &img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_NV12) == 0 ) {
-            sprintf(str, "decoded_file%d.pgm", i);
-            SaveBufferRGB(img_buffer, width, height, str);
-            //SaveBufferNV12(img_buffer, width, height, str);
+        
+
+        for ( int i = 0; i < 5; i++ ) {
+
+            pkt_buffer_size = buffer_size;
+            img_buffer_size = buffer_size;
+
+            //if ( i > 20 ) {
             
-            //formatConversion(width, height, img_buffer, pkt_buffer, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB);
-            //sprintf(str, "decoded_file_conv%d.pgm", i);
-            //SaveBufferRGB(pkt_buffer, width, height, str);
+            if ( i == 60 ) {
+                nvpipe_set_bitrate(codec, 10000);
+            }
 
-        } else {
-            printf("decoding frame not written to file: %d\n", i);
-        }
+            for(size_t y=0;y<height;y++) {
+                for(size_t x=0;x<width;x++) {
+                    int index = y * width + x;
+                    //img_ptr0[index*4] = (x + y + i*10);
+                    //img_ptr0[index*4+1] = 128 + y + i *15;
+                    //img_ptr0[index*4+2] = 64 + x;
+                    //img_ptr0[index*4+3] = 255;
+                }
+            }
 
-    }
+            char str[15];
+            
+            int num = i % 100;
+
+            sprintf(str, "encoded_file%d.pgm", num);
+            SaveBufferRGBA(img_buffer, width, height, str);
+            nvpipe_encode(codec, img_buffer, buffer_size, pkt_buffer, &pkt_buffer_size, width, height, NVPIPE_IMAGE_FORMAT_RGBA);
+            
+            //memset(pkt_buffer, 23, pkt_buffer_size);
+            //printf( "frame: %d, packet size: %zu\n", i, pkt_buffer_size);
+            if (nvpipe_decode(codec2, pkt_buffer, pkt_buffer_size, img_buffer, img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_RGBA) == 0 ) {
+            //if (nvpipe_decode(codec, pkt_buffer, pkt_buffer_size, img_buffer, img_buffer_size, &width, &height, NVPIPE_IMAGE_FORMAT_NV12) == 0 ) {
+                sprintf(str, "decoded_file%d.pgm", i);
+                SaveBufferRGBA(img_buffer, width, height, str);
+                //SaveBufferNV12(img_buffer, width, height, str);
+                
+                //formatConversion(width, height, img_buffer, pkt_buffer, NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB);
+                //sprintf(str, "decoded_file_conv%d.pgm", i);
+                //SaveBufferRGB(pkt_buffer, width, height, str);
 
-    nvpipe_destroy_instance(codec);
-    //nvpipe_destroy_instance(codec2);
+            } else {
+                printf("decoding frame not written to file: %d\n", i);
+            }
+
+        }
 
-    free(img_buffer);
-    free(pkt_buffer);
+        nvpipe_destroy_instance(codec);
+        nvpipe_destroy_instance(codec2);
 
-    return 0;
-    */
-}
+        free(img_buffer);
+        free(pkt_buffer);
+
+        return 0;
+        
+    }
diff --git a/libnvpipecodec/nvpipecodec264.cxx b/libnvpipecodec/nvpipecodec264.cxx
index 30d58dc..328052b 100644
--- a/libnvpipecodec/nvpipecodec264.cxx
+++ b/libnvpipecodec/nvpipecodec264.cxx
@@ -189,6 +189,7 @@ int NvPipeCodec264::encode( void* buffer,
 
         switch ( encoder_conversion_flag_ ) {
             case NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12:
+            case NVPIPE_IMAGE_FORMAT_CONVERSION_RGBA_TO_NV12:
             case NVPIPE_IMAGE_FORMAT_CONVERSION_RGB_TO_NV12:
                 if ( encoder_converted_image_buffer_size_ < 
                                                 num_pixels * 3 / 2 ) {
@@ -228,6 +229,7 @@ int NvPipeCodec264::encode( void* buffer,
     switch ( encoder_conversion_flag_ ) {
     case NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12:
     case NVPIPE_IMAGE_FORMAT_CONVERSION_RGB_TO_NV12:
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_RGBA_TO_NV12:
         //formatConversion(width_, height_, 
         //                frame_, encoder_converted_image_buffer_,
         //                encoder_conversion_flag_);
@@ -395,7 +397,24 @@ int NvPipeCodec264::decode( void* output_picture,
         frameSize *= height;
         frameSize *= 4;
         break;
-
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGBA:
+        frameSize = width;
+        frameSize *= height;
+        frameSize *= 4;
+        if (frameSize > output_size ) {
+            output_size = frameSize;
+            av_packet_unref(&decoder_packet_);
+            printf("frame size larger than frame_buffer_size_,\
+                    something went wrong!\n");
+            return -1;
+        }
+        output_size = frameSize;
+        formatConversionAVFrameRGBAReuseMemory( decoder_frame_,
+                                                output_picture,
+                                                &memgpu2_);
+        av_packet_unref(&decoder_packet_);
+        return 0;
+        break;
     case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB:
         frameSize = width;
         frameSize *= height;
@@ -484,7 +503,12 @@ int NvPipeCodec264::getFormatConversionEnum(
             NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12 :
             NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB;
         break;
-
+    case NVPIPE_IMAGE_FORMAT_RGBA:
+        pixel_format = AV_PIX_FMT_NV12;
+        conversion_flag = encoder_flag ?
+            NVPIPE_IMAGE_FORMAT_CONVERSION_RGBA_TO_NV12 :
+            NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGBA;
+        break;
     case NVPIPE_IMAGE_FORMAT_RGB:
         pixel_format = AV_PIX_FMT_NV12;
         conversion_flag = encoder_flag ?
diff --git a/libnvpipeutil/format.h b/libnvpipeutil/format.h
index d49f497..37313b0 100644
--- a/libnvpipeutil/format.h
+++ b/libnvpipeutil/format.h
@@ -24,25 +24,13 @@
 #pragma once
 
 #include <stdlib.h>
-#include <libavformat/avformat.h>
+#include "libavformat/avformat.h"
+#include "nvpipe.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-enum NVPipeCodecID {
-    NVPIPE_CODEC_ID_NULL,
-    NVPIPE_CODEC_ID_H264
-};
-
-enum NVPipeImageFormat {
-    NVPIPE_IMAGE_FORMAT_NULL,
-    NVPIPE_IMAGE_FORMAT_RGB,
-    NVPIPE_IMAGE_FORMAT_ARGB,
-    NVPIPE_IMAGE_FORMAT_YUV420P,
-    NVPIPE_IMAGE_FORMAT_YUV444P,
-    NVPIPE_IMAGE_FORMAT_NV12
-};
 
 /*!
  *  NVPIPE_IMAGE_FORMAT_CONVERSION_X_TO_Y
@@ -55,12 +43,13 @@ enum NVPipeImageFormatConversion {
     NVPIPE_IMAGE_FORMAT_CONVERSION_NULL,
     NVPIPE_IMAGE_FORMAT_CONVERSION_RGB_TO_NV12,
     NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB,
+    NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12,
     NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB,
-    NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12
+    NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGBA,
+    NVPIPE_IMAGE_FORMAT_CONVERSION_RGBA_TO_NV12
 };
 
 typedef struct _nvpipeMemGpu2 {
-
     unsigned int* d_buffer_1_;
     unsigned int* d_buffer_2_;
     size_t d_buffer_1_size_;
@@ -90,6 +79,14 @@ int formatConversionAVFrameRGB( AVFrame *frame,
 int formatConversionAVFrameRGBReuseMemory( AVFrame *frame,
                                 void *buffer,
                                 nvpipeMemGpu2 *mem_gpu2);
+
+int formatConversionAVFrameRGBA( AVFrame *frame,
+                                 void *buffer);
+
+int formatConversionAVFrameRGBAReuseMemory( AVFrame *frame,
+                                void *buffer,
+                                nvpipeMemGpu2 *mem_gpu2);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/libnvpipeutil/formatConversionCuda.h b/libnvpipeutil/formatConversionCuda.h
index 46a5330..7239952 100644
--- a/libnvpipeutil/formatConversionCuda.h
+++ b/libnvpipeutil/formatConversionCuda.h
@@ -38,11 +38,19 @@ cudaError launch_CudaARGB2NV12Process(  int w, int h,
                                         CUdeviceptr pARGBImage, 
                                         CUdeviceptr pNV12Image);
 
-cudaError launch_CudaNV12TOARGBProcess(  int w, int h, 
+cudaError launch_CudaNV12TOARGBProcess( int w, int h, 
                                         CUdeviceptr pNV12Image, 
                                         CUdeviceptr pARGBImage);
 
-cudaError launch_CudaRGB2NV12Process(  int w, int h, 
+cudaError launch_CudaRGBA2NV12Process(  int w, int h, 
+                                        CUdeviceptr pARGBImage, 
+                                        CUdeviceptr pNV12Image);
+
+cudaError launch_CudaNV12TORGBAProcess( int w, int h, 
+                                        CUdeviceptr pNV12Image, 
+                                        CUdeviceptr pARGBImage);
+
+cudaError launch_CudaRGB2NV12Process(   int w, int h, 
                                         CUdeviceptr pRGBImage, 
                                         CUdeviceptr pNV12Image);
 
@@ -55,6 +63,11 @@ cudaError launch_CudaNV12TORGBProcessDualChannel( int w, int h,
                                         CUdeviceptr pUVPlane,
                                         CUdeviceptr pRGBImage);
 
+cudaError launch_CudaNV12TORGBAProcessDualChannel( int w, int h,
+                                        CUdeviceptr pYPlane,
+                                        CUdeviceptr pUVPlane,
+                                        CUdeviceptr pRGBImage);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/libnvpipeutil/kernels.cu b/libnvpipeutil/kernels.cu
index 420512e..7abf170 100644
--- a/libnvpipeutil/kernels.cu
+++ b/libnvpipeutil/kernels.cu
@@ -35,6 +35,17 @@ __global__ static void CudaProcessARGB2Y(int w, int h, uchar4 * pARGBImage, unsi
   }
 }
 
+__global__ static void CudaProcessRGBA2Y(int w, int h, uchar4 * pRGBAImage, unsigned char * pNV12ImageY)
+{
+  unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
+  unsigned int j = blockIdx.y*blockDim.y + threadIdx.y; 
+  if(i<w && j<h)
+  {
+    uchar4 rgba=pRGBAImage[w*j+i];
+    pNV12ImageY[w*j+i]= RGBA2Y(rgba);
+  }
+}
+
 __global__ static void CudaProcessRGB2Y(int w, int h, uchar3 * pRGBImage, unsigned char * pNV12ImageY)
 {
   unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
@@ -56,6 +67,17 @@ __forceinline__  __device__ float ARGB2V(uchar4  argb)
   return clamp((0.439 * argb.y) - (0.368 * argb.z) - (0.0701 * argb.w)+128.0,0,255);
 }
 
+__forceinline__  __device__ float RGBA2U(uchar4  argb)
+{
+  return clamp(-(0.148 * argb.x) - (0.291 * argb.y) + (0.439 * argb.z)+128.0,0,255);
+}
+
+__forceinline__  __device__ float RGBA2V(uchar4  argb)
+{
+  return clamp((0.439 * argb.x) - (0.368 * argb.y) - (0.0701 * argb.z)+128.0,0,255);
+}
+
+
 __forceinline__  __device__ float RGB2U(uchar3  rgb)
 {
   return clamp(-(0.148 * rgb.x) - (0.291 * rgb.y) + (0.439 * rgb.z)+128.0,0,255);
@@ -99,6 +121,39 @@ __global__ static void CudaProcessARGB2UV(int w, int h, uchar4 * pARGBImage, uns
   }
 }
 
+__global__ static void CudaProcessRGBA2UV(int w, int h, uchar4 * pRGBAImage, unsigned char * pNV12ImageUV)
+{
+  unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
+  unsigned int j = blockIdx.y*blockDim.y + threadIdx.y; 
+  unsigned int fi = i*2;//full size image i
+  unsigned int fj = j*2;//full size image j
+  unsigned int fw = w*2;//full size image w
+  unsigned int fh = h*2;//full size image h
+  unsigned int u_idx = i*2 + 1 + j*w*2;
+  unsigned int v_idx = i*2 + j*w*2;
+  if(fi<fw-1 && fj<fh-1)
+  {
+    uchar4 rgba1=pRGBAImage[fj*fw+fi];
+    uchar4 rgba2=pRGBAImage[fj*fw+fi+1];
+    uchar4 rgba3=pRGBAImage[(fj+1)*fw+fi];
+    uchar4 rgba4=pRGBAImage[(fj+1)*fw+fi+1];
+
+    float U  = RGBA2U(rgba1);
+    float U2 = RGBA2U(rgba2);
+    float U3 = RGBA2U(rgba3);
+    float U4 = RGBA2U(rgba4);
+
+    float V =  RGBA2V(rgba1);
+    float V2 = RGBA2V(rgba2);
+    float V3 = RGBA2V(rgba3);
+    float V4 = RGBA2V(rgba4);
+
+    pNV12ImageUV[u_idx] = (U+U2+U3+U4)/4.0;
+    pNV12ImageUV[v_idx] = (V+V2+V3+V4)/4.0;
+  }
+}
+
+
 __global__ static void CudaProcessRGB2UV(int w, int h, uchar3 * pRGBImage, unsigned char * pNV12ImageUV)
 {
   unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
@@ -168,6 +223,45 @@ __global__ static void CudaProcessNV122ARGB(int w, int h, unsigned char * pNV12I
   }
 }
 
+
+__global__ static void CudaProcessNV122RGBA(int w, int h, unsigned char * pNV12Image, uchar4 * pRGBAImage)
+{
+  unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
+  unsigned int j = blockIdx.y*blockDim.y + threadIdx.y; 
+  if(i<w && j<h)
+  {
+    unsigned int v_idx = (j/2*w/2 + i/2)*2; // ( j/2*w/2 + i/2 ) * 2;
+    unsigned int u_idx = v_idx + 1;
+    
+    unsigned int offset_idx = w*h;
+    unsigned int pixel_idx = j*w+i;
+    unsigned int channel = threadIdx.z;
+    
+    if ( channel == 0 ) {
+        pRGBAImage[w*j+i].w = 255;
+    } else if ( channel == 1) {
+        pRGBAImage[w*j+i].x = clamp(
+                                (pNV12Image[pixel_idx]-16) * 1.164 +
+                                0 +
+                                (pNV12Image[offset_idx+v_idx]-128) * 1.596
+                                , 0, 255);
+    } else if ( channel == 2) {
+        pRGBAImage[w*j+i].y = clamp(
+                                (pNV12Image[pixel_idx]-16) * 1.164 +
+                                (pNV12Image[offset_idx+u_idx]-128) * -0.392 +
+                                (pNV12Image[offset_idx+v_idx]-128) * -0.813
+                                , 0, 255);
+    } else if ( channel == 3) {
+        pRGBAImage[w*j+i].z = clamp(
+                                (pNV12Image[pixel_idx]-16) * 1.164 +
+                                (pNV12Image[offset_idx+u_idx]-128) * 2.017 +
+                                0
+                                , 0, 255);
+    }
+  }
+}
+
+
 __global__ static void CudaProcessNV122RGB(int w, int h, unsigned char * pNV12Image, uchar3 * pRGBImage)
 {
   unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
@@ -238,6 +332,42 @@ __global__ static void CudaProcessAVFrameNV122RGB(int w, int h, unsigned char *
 }
 
 
+__global__ static void CudaProcessAVFrameNV122RGBA(int w, int h, unsigned char * pYImage, unsigned char * pUVImage, uchar4 * pRGBAImage)
+{
+  unsigned int i = blockIdx.x*blockDim.x + threadIdx.x;
+  unsigned int j = blockIdx.y*blockDim.y + threadIdx.y; 
+  if(i<w && j<h)
+  {
+    unsigned int v_idx = (j/2*w/2 + i/2)*2; // ( j/2*w/2 + i/2 ) * 2;
+    unsigned int u_idx = v_idx + 1;
+
+    unsigned int pixel_idx = j*w+i;
+    unsigned int channel = threadIdx.z;
+    
+    if ( channel == 1) {
+        pRGBAImage[w*j+i].x = clamp(
+                                (pYImage[pixel_idx]-16) * 1.164 +
+                                0 +
+                                (pUVImage[v_idx]-128) * 1.596
+                                , 0, 255);
+    } else if ( channel == 2) {
+        pRGBAImage[w*j+i].y = clamp(
+                                (pYImage[pixel_idx]-16) * 1.164 +
+                                (pUVImage[u_idx]-128) * -0.392 +
+                                (pUVImage[v_idx]-128) * -0.813
+                                , 0, 255);
+    } else if ( channel == 3) {
+        pRGBAImage[w*j+i].z = clamp(
+                                (pYImage[pixel_idx]-16) * 1.164 +
+                                (pUVImage[u_idx]-128) * 2.017 +
+                                0
+                                , 0, 255);
+    } else if ( channel == 4) {
+        pRGBAImage[w*j+i].w = 255;
+    }
+  }
+}
+
 extern "C" 
 {
   // I really think the code is actually using RGBA instead of ARGB
@@ -256,6 +386,22 @@ extern "C"
     cudaError err = cudaGetLastError();                                
     return err;
   }
+  
+  cudaError launch_CudaRGBA2NV12Process(int w, int h, CUdeviceptr pRGBAImage, CUdeviceptr pNV12Image )
+  {
+    {
+      dim3 dimBlock(16, 16, 1);
+      dim3 dimGrid(((w)+dimBlock.x-1)/dimBlock.x, ((h)+dimBlock.y-1)/dimBlock.y, 1);
+      CudaProcessRGBA2Y<<<dimGrid, dimBlock>>>(w, h, (uchar4 *)pRGBAImage, (unsigned char *)pNV12Image);
+    }
+    {
+      dim3 dimBlock(16, 16, 1);
+      dim3 dimGrid(((w/2)+dimBlock.x-1)/dimBlock.x, ((h/2)+dimBlock.y-1)/dimBlock.y, 1);
+      CudaProcessRGBA2UV<<<dimGrid, dimBlock>>>(w/2, h/2, (uchar4 *)pRGBAImage, ((unsigned char *)pNV12Image)+w*h);
+    }
+    cudaError err = cudaGetLastError();                                
+    return err;
+  }
 
   cudaError launch_CudaNV12TOARGBProcess(int w, int h, CUdeviceptr pNV12Image, CUdeviceptr pARGBImage )
   {
@@ -268,6 +414,17 @@ extern "C"
     return err;
   }
 
+  cudaError launch_CudaNV12TORGBAProcess(int w, int h, CUdeviceptr pNV12Image, CUdeviceptr pRGBAImage )
+  {
+    {
+      dim3 dimBlock(16, 16, 4); // might be a bad idea to use 1024 threads per SM;
+      dim3 dimGrid(((w)+dimBlock.x-1)/dimBlock.x, ((h)+dimBlock.y-1)/dimBlock.y, 1);
+      CudaProcessNV122RGBA<<<dimGrid, dimBlock>>>(w, h, (unsigned char *)pNV12Image, (uchar4 *)pRGBAImage);
+    }
+    cudaError err = cudaGetLastError();                                
+    return err;
+  }
+
   cudaError launch_CudaRGB2NV12Process(int w, int h, CUdeviceptr pRGBImage, CUdeviceptr pNV12Image )
   {
     {
@@ -305,5 +462,14 @@ extern "C"
     return err;
   }
 
+  cudaError launch_CudaNV12TORGBAProcessDualChannel( int w, int h, CUdeviceptr pYPlane, CUdeviceptr pUVPlane, CUdeviceptr pRGBImage) {
+    {
+      dim3 dimBlock(16, 16, 4);
+      dim3 dimGrid(((w)+dimBlock.x-1)/dimBlock.x, ((h)+dimBlock.y-1)/dimBlock.y, 1);
+      CudaProcessAVFrameNV122RGBA<<<dimGrid, dimBlock>>>(w, h, (unsigned char *)pYPlane, (unsigned char *)pUVPlane, (uchar4 *)pRGBImage);
+    }
+    cudaError err = cudaGetLastError();                                
+    return err;
+  }
 
 }
diff --git a/libnvpipeutil/util.cxx b/libnvpipeutil/util.cxx
index 972926e..9a4d700 100644
--- a/libnvpipeutil/util.cxx
+++ b/libnvpipeutil/util.cxx
@@ -147,26 +147,36 @@ int formatConversion(   int w, int h,
     switch ( conversionEnum ) {
     case NVPIPE_IMAGE_FORMAT_CONVERSION_NULL:
         return -1;
-    case NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12:
-        sourceSize = sizeof(uint8_t)*w*h*4;
-        destinationSize = sizeof(uint8_t)*w*h*3/2;
-        funcPtr = &launch_CudaARGB2NV12Process;
-        break;
     case NVPIPE_IMAGE_FORMAT_CONVERSION_RGB_TO_NV12:
         sourceSize = sizeof(uint8_t)*w*h*3;
         destinationSize = sizeof(uint8_t)*w*h*3/2;
         funcPtr = &launch_CudaRGB2NV12Process;
         break;
-    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB:
-        sourceSize = sizeof(uint8_t)*w*h*3/2;
-        destinationSize = sizeof(uint8_t)*w*h*4;
-        funcPtr = &launch_CudaNV12TOARGBProcess;
-        break;
     case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB:
         sourceSize = sizeof(uint8_t)*w*h*3/2;
         destinationSize = sizeof(uint8_t)*w*h*3;
         funcPtr = &launch_CudaNV12TORGBProcess;
         break;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_RGBA_TO_NV12:
+        sourceSize = sizeof(uint8_t)*w*h*4;
+        destinationSize = sizeof(uint8_t)*w*h*3/2;
+        funcPtr = &launch_CudaRGBA2NV12Process;
+        break;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGBA:
+        sourceSize = sizeof(uint8_t)*w*h*3/2;
+        destinationSize = sizeof(uint8_t)*w*h*4;
+        funcPtr = &launch_CudaNV12TORGBAProcess;
+        break;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12:
+        sourceSize = sizeof(uint8_t)*w*h*4;
+        destinationSize = sizeof(uint8_t)*w*h*3/2;
+        funcPtr = &launch_CudaARGB2NV12Process;
+        break;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB:
+        sourceSize = sizeof(uint8_t)*w*h*3/2;
+        destinationSize = sizeof(uint8_t)*w*h*4;
+        funcPtr = &launch_CudaNV12TOARGBProcess;
+        break;
     default:
         return -1;
     }
@@ -214,14 +224,14 @@ int formatConversionReuseMemory(   int w, int h,
     switch ( conversionEnum ) {
     case NVPIPE_IMAGE_FORMAT_CONVERSION_NULL:
         return -1;
-    case NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12:
-        sourceSize = sizeof(uint8_t)*w*h*4;
-        destinationSize = sizeof(uint8_t)*w*h*3/2;
-        smallBuffer = &d_destinationPtr;
-        smallBufferSize = destinationSize;
-        largeBuffer = &d_sourcePtr;
-        largeBufferSize = sourceSize;
-        funcPtr = &launch_CudaARGB2NV12Process;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB:
+        sourceSize = sizeof(uint8_t)*w*h*3/2;
+        destinationSize = sizeof(uint8_t)*w*h*3;
+        smallBuffer = &d_sourcePtr;
+        smallBufferSize = sourceSize;
+        largeBuffer = &d_destinationPtr;
+        largeBufferSize = destinationSize;
+        funcPtr = &launch_CudaNV12TORGBProcess;
         break;
     case NVPIPE_IMAGE_FORMAT_CONVERSION_RGB_TO_NV12:
         sourceSize = sizeof(uint8_t)*w*h*3;
@@ -232,23 +242,41 @@ int formatConversionReuseMemory(   int w, int h,
         largeBufferSize = sourceSize;
         funcPtr = &launch_CudaRGB2NV12Process;
         break;
-    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB:
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGBA:
         sourceSize = sizeof(uint8_t)*w*h*3/2;
         destinationSize = sizeof(uint8_t)*w*h*4;
         smallBuffer = &d_sourcePtr;
         smallBufferSize = sourceSize;
         largeBuffer = &d_destinationPtr;
         largeBufferSize = destinationSize;
-        funcPtr = &launch_CudaNV12TOARGBProcess;
+        funcPtr = &launch_CudaNV12TORGBAProcess;
         break;
-    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_RGB:
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_RGBA_TO_NV12:
+        sourceSize = sizeof(uint8_t)*w*h*4;
+        destinationSize = sizeof(uint8_t)*w*h*3/2;
+        smallBuffer = &d_destinationPtr;
+        smallBufferSize = destinationSize;
+        largeBuffer = &d_sourcePtr;
+        largeBufferSize = sourceSize;
+        funcPtr = &launch_CudaRGBA2NV12Process;
+        break;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_NV12_TO_ARGB:
         sourceSize = sizeof(uint8_t)*w*h*3/2;
-        destinationSize = sizeof(uint8_t)*w*h*3;
+        destinationSize = sizeof(uint8_t)*w*h*4;
         smallBuffer = &d_sourcePtr;
         smallBufferSize = sourceSize;
         largeBuffer = &d_destinationPtr;
         largeBufferSize = destinationSize;
-        funcPtr = &launch_CudaNV12TORGBProcess;
+        funcPtr = &launch_CudaNV12TOARGBProcess;
+        break;
+    case NVPIPE_IMAGE_FORMAT_CONVERSION_ARGB_TO_NV12:
+        sourceSize = sizeof(uint8_t)*w*h*4;
+        destinationSize = sizeof(uint8_t)*w*h*3/2;
+        smallBuffer = &d_destinationPtr;
+        smallBufferSize = destinationSize;
+        largeBuffer = &d_sourcePtr;
+        largeBufferSize = sourceSize;
+        funcPtr = &launch_CudaARGB2NV12Process;
         break;
     default:
         return -1;
@@ -336,6 +364,12 @@ int formatConversionAVFrameRGBReuseMemory( AVFrame *frame,
             return ret;
             break;
         }
+    case AV_PIX_FMT_RGBA:
+        {
+            printf("not supported yet\n");
+            break;
+        }
+
     case AV_PIX_FMT_ARGB:
         {
             printf("not supported yet\n");
@@ -387,10 +421,86 @@ int formatConversionAVFrameRGB( AVFrame *frame,
             checkCudaErrors(
                 cudaMemcpy( buffer, d_bufferPtr, 
                 sizeof(uint8_t)*w*h*3, cudaMemcpyDeviceToHost ));
+            
+            checkCudaErrors(cudaFree(d_bufferPtr));
+            checkCudaErrors(cudaFree(d_YPtr));
+            checkCudaErrors(cudaFree(d_UVPtr));
+            
+            return ret;
+            break;
+        }
+    case AV_PIX_FMT_ARGB:
+        {
+            printf("not supported yet\n");
+            break;
+        }
+    default:
+        {
+            printf("default?\n");
+            break;
+        }
+    }
+    return 0;
+}
+
+int formatConversionAVFrameRGBAReuseMemory( AVFrame *frame, 
+                                void *buffer,
+                                nvpipeMemGpu2 *mem_gpu2) {
+
+    switch( frame->format ) {
+    case AV_PIX_FMT_NV12:
+        {
+            unsigned int * d_YPtr;
+            unsigned int * d_UVPtr;
+            unsigned int * d_bufferPtr;
+            
+            int w = frame->width;
+            int h = frame->height;
+
+            size_t pixel_count = w * h * sizeof(uint8_t);
+
+            if (pixel_count*4 > mem_gpu2->d_buffer_1_size_ ||
+                pixel_count*3/2 > mem_gpu2->d_buffer_2_size_ ) {
+                printf("mem reallocate!\n");
+                allocateMemGpu2(mem_gpu2,
+                                pixel_count*4,
+                                pixel_count*3/2);
+            }
+
+            d_bufferPtr = mem_gpu2->d_buffer_1_;
+            d_YPtr = mem_gpu2->d_buffer_2_;
+
+            //Alert!
+            //  ugly coade ahead: 
+            //  pixel_count/4 because CUDA offset is per word!
+            d_UVPtr = mem_gpu2->d_buffer_2_ + pixel_count/4;
+
+            checkCudaErrors(
+                cudaMemcpy( d_YPtr, frame->data[0], sizeof(uint8_t)*w*h, 
+                            cudaMemcpyHostToDevice ));
+            checkCudaErrors(
+                cudaMemcpy( d_UVPtr, frame->data[1], sizeof(uint8_t)*w*h/2, 
+                            cudaMemcpyHostToDevice ));
+            
+            int ret =   launch_CudaNV12TORGBAProcessDualChannel(
+                    frame->width, frame->height,
+                    (CUdeviceptr) d_YPtr,
+                    (CUdeviceptr) d_UVPtr,
+                    (CUdeviceptr) d_bufferPtr);
+
+            checkCudaErrors(
+                cudaMemcpy( buffer, d_bufferPtr, 
+                sizeof(uint8_t)*w*h*4, cudaMemcpyDeviceToHost ));
 
             return ret;
             break;
         }
+    case AV_PIX_FMT_RGBA:
+        {
+            printf("not supported yet\n");
+            break;
+        }
+
     case AV_PIX_FMT_ARGB:
         {
             printf("not supported yet\n");
@@ -405,6 +515,63 @@ int formatConversionAVFrameRGB( AVFrame *frame,
     return 0;
 }
 
+int formatConversionAVFrameRGBA( AVFrame *frame, 
+                                void *buffer) {
+
+    switch( frame->format ) {
+    case AV_PIX_FMT_NV12:
+        {
+            unsigned int * d_YPtr;
+            unsigned int * d_UVPtr;
+            unsigned int * d_bufferPtr;
+            
+            int w = frame->width;
+            int h = frame->height;
+
+            size_t pixel_count = w * h * sizeof(uint8_t);
+            checkCudaErrors(
+                cudaMalloc( (void **) &(d_bufferPtr), pixel_count*4));
+            checkCudaErrors(
+                cudaMalloc( (void **) &(d_YPtr), pixel_count));
+            checkCudaErrors(
+                cudaMalloc( (void **) &(d_UVPtr), pixel_count/2));
+
+            checkCudaErrors(
+                cudaMemcpy( d_YPtr, frame->data[0], sizeof(uint8_t)*w*h, 
+                            cudaMemcpyHostToDevice ));
+            checkCudaErrors(
+                cudaMemcpy( d_UVPtr, frame->data[1], sizeof(uint8_t)*w*h/2, 
+                            cudaMemcpyHostToDevice ));
+            
+            int ret =   launch_CudaNV12TORGBAProcessDualChannel(
+                    frame->width, frame->height,
+                    (CUdeviceptr) d_YPtr,
+                    (CUdeviceptr) d_UVPtr,
+                    (CUdeviceptr) d_bufferPtr);
+
+            checkCudaErrors(
+                cudaMemcpy( buffer, d_bufferPtr, 
+                sizeof(uint8_t)*w*h*4, cudaMemcpyDeviceToHost ));
+
+            checkCudaErrors(cudaFree(d_bufferPtr));
+            checkCudaErrors(cudaFree(d_YPtr));
+            checkCudaErrors(cudaFree(d_UVPtr));
+            return ret;
+            break;
+        }
+    case AV_PIX_FMT_ARGB:
+        {
+            printf("not supported yet\n");
+            break;
+        }
+    default:
+        {
+            printf("default?\n");
+            break;
+        }
+    }
+    return 0;
+}
 
 void destroyMemGpu2(nvpipeMemGpu2 *mem_gpu) {
     if ( mem_gpu->d_buffer_1_ ) {
diff --git a/nvpipe.h b/nvpipe.h
index bd0e0f2..5d88067 100644
--- a/nvpipe.h
+++ b/nvpipe.h
@@ -23,13 +23,27 @@
 #pragma once
 
 #include <stdlib.h>
-#include "libnvpipeutil/format.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 
+enum NVPipeCodecID {
+    NVPIPE_CODEC_ID_NULL,
+    NVPIPE_CODEC_ID_H264
+};
+
+enum NVPipeImageFormat {
+    NVPIPE_IMAGE_FORMAT_NULL,
+    NVPIPE_IMAGE_FORMAT_RGB,
+    NVPIPE_IMAGE_FORMAT_ARGB,
+    NVPIPE_IMAGE_FORMAT_RGBA,
+    NVPIPE_IMAGE_FORMAT_YUV420P,
+    NVPIPE_IMAGE_FORMAT_YUV444P,
+    NVPIPE_IMAGE_FORMAT_NV12
+};
+
 typedef struct _nvpipe {
     enum NVPipeCodecID type_;
     void *codec_ptr_;
